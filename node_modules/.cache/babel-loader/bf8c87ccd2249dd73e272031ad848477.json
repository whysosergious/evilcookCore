{"ast":null,"code":"/**\n * recursive function loop.\n * One for arrays and one for Objects.\n * Same name for both types allows for automatic type detection and conversion.\n */\n// name our method\nconst methodName = 'recLoop'; // Check if prototype names are taken\n\nObject.prototype.hasOwnProperty(methodName) && THROW_ERROR('Object');\nArray.prototype.hasOwnProperty(methodName) && THROW_ERROR('Array');\n\nfunction THROW_ERROR(info) {\n  throw new Error(`Property name '${methodName}' clashes with an existing method in ${info} prototypes`);\n} // referencing objects\n\n\n_c = THROW_ERROR;\nconst TargetObject = Object;\nconst TargetArray = Array;\n/**\n * We define our properties and handle data types\n * Our functions receive callbacks and if set\n * an int with a loop limit.\n */\n\nObject.defineProperty(TargetObject.prototype, methodName, {\n  value: function (callback, limit) {\n    let array = Object.entries(this); // Object entries are made into arrays\n\n    return iterate(callback, array, limit); // and we call our recursive function\n  },\n  enumerable: false,\n  writable: true\n});\nObject.defineProperty(TargetArray.prototype, methodName, {\n  value: function (callback, limit) {\n    let array = this; // arrays are kept as is\n\n    return iterate(callback, array, limit);\n  },\n  enumerable: true,\n  writable: true\n});\n/**\n * Recursive function that iterates through\n * an array either in full or up to the set\n * limit of iterations\n * @param {function} callback\n * @param {array} array\n * @param {number} limit\n */\n\nfunction iterate(callback, array, limit = null) {\n  let length = array.length;\n  const count = length < limit ? length : limit || length; // iteration count\n\n  let i = 0;\n\n  function next() {\n    let [entry, entry2 = undefined] = Array.isArray(array[i]) ? array[i] : [array[i]];\n\n    if (i++ >= count) {\n      return;\n    } // value, index, key because it's seems easier to handle atm\n\n\n    return callback(entry2 || entry, i, entry2 && entry), next();\n  } // Give it a push\n\n\n  next();\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"THROW_ERROR\");","map":{"version":3,"sources":["C:/webWork/olivertwist/src/logic/methods.js"],"names":["methodName","Object","prototype","hasOwnProperty","THROW_ERROR","Array","info","Error","TargetObject","TargetArray","defineProperty","value","callback","limit","array","entries","iterate","enumerable","writable","length","count","i","next","entry","entry2","undefined","isArray"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AACA,MAAMA,UAAU,GAAG,SAAnB,C,CAEA;;AACAC,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCH,UAAhC,KAA+CI,WAAW,CAAC,QAAD,CAA1D;AACAC,KAAK,CAACH,SAAN,CAAgBC,cAAhB,CAA+BH,UAA/B,KAA8CI,WAAW,CAAC,OAAD,CAAzD;;AACA,SAASA,WAAT,CAAuBE,IAAvB,EAA8B;AAAE,QAAM,IAAIC,KAAJ,CAAY,kBAAkBP,UAAY,wCAAwCM,IAAM,aAAxF,CAAN;AAA8G,C,CAE9I;;;KAFSF,W;AAGT,MAAMI,YAAY,GAAGP,MAArB;AACA,MAAMQ,WAAW,GAAGJ,KAApB;AAEA;AACA;AACA;AACA;AACA;;AACAJ,MAAM,CAACS,cAAP,CAAuBF,YAAY,CAACN,SAApC,EAA+CF,UAA/C,EAA2D;AAC1DW,EAAAA,KAAK,EAAE,UAAUC,QAAV,EAAoBC,KAApB,EAA4B;AAClC,QAAIC,KAAK,GAAGb,MAAM,CAACc,OAAP,CAAe,IAAf,CAAZ,CADkC,CACA;;AAElC,WAAOC,OAAO,CAAEJ,QAAF,EAAYE,KAAZ,EAAmBD,KAAnB,CAAd,CAHkC,CAGO;AAEzC,GANyD;AAMvDI,EAAAA,UAAU,EAAE,KAN2C;AAMpCC,EAAAA,QAAQ,EAAE;AAN0B,CAA3D;AAQAjB,MAAM,CAACS,cAAP,CAAsBD,WAAW,CAACP,SAAlC,EAA6CF,UAA7C,EAAyD;AACxDW,EAAAA,KAAK,EAAE,UAAUC,QAAV,EAAoBC,KAApB,EAA4B;AAClC,QAAIC,KAAK,GAAG,IAAZ,CADkC,CACf;;AAEnB,WAAOE,OAAO,CAAEJ,QAAF,EAAYE,KAAZ,EAAmBD,KAAnB,CAAd;AAEA,GANuD;AAMrDI,EAAAA,UAAU,EAAE,IANyC;AAMnCC,EAAAA,QAAQ,EAAE;AANyB,CAAzD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASF,OAAT,CAAkBJ,QAAlB,EAA4BE,KAA5B,EAAmCD,KAAK,GAAC,IAAzC,EAAgD;AAC/C,MAAIM,MAAM,GAAGL,KAAK,CAACK,MAAnB;AACA,QAAMC,KAAK,GAAGD,MAAM,GAAGN,KAAT,GAAiBM,MAAjB,GAA0BN,KAAK,IAAIM,MAAjD,CAF+C,CAEW;;AAC1D,MAAIE,CAAC,GAAG,CAAR;;AAEA,WAASC,IAAT,GAAgB;AACf,QAAI,CAAEC,KAAF,EAASC,MAAM,GAACC,SAAhB,IAA8BpB,KAAK,CAACqB,OAAN,CAAcZ,KAAK,CAACO,CAAD,CAAnB,IAA0BP,KAAK,CAACO,CAAD,CAA/B,GAAqC,CAACP,KAAK,CAACO,CAAD,CAAN,CAAvE;;AACA,QAAKA,CAAC,MAAMD,KAAZ,EAAoB;AAAE;AAAQ,KAFf,CAIf;;;AACA,WAASR,QAAQ,CAAEY,MAAM,IAAID,KAAZ,EAAmBF,CAAnB,EAAsBG,MAAM,IAAID,KAAhC,CAAR,EAAiDD,IAAI,EAA9D;AACA,GAX8C,CAW7C;;;AACFA,EAAAA,IAAI;AACJ","sourcesContent":["/**\n * recursive function loop.\n * One for arrays and one for Objects.\n * Same name for both types allows for automatic type detection and conversion.\n */\n\n// name our method\nconst methodName = 'recLoop';\n\n// Check if prototype names are taken\nObject.prototype.hasOwnProperty(methodName) && THROW_ERROR('Object');\nArray.prototype.hasOwnProperty(methodName) && THROW_ERROR('Array');\nfunction THROW_ERROR ( info ) { throw new Error( `Property name '${ methodName }' clashes with an existing method in ${ info } prototypes` ) }\n\n// referencing objects\nconst TargetObject = Object;\nconst TargetArray = Array;\n\n/**\n * We define our properties and handle data types\n * Our functions receive callbacks and if set\n * an int with a loop limit.\n */\nObject.defineProperty( TargetObject.prototype, methodName, {\n\tvalue: function( callback, limit ) {\n\t\tlet array = Object.entries(this);\t// Object entries are made into arrays\n\n\t\treturn iterate( callback, array, limit )\t// and we call our recursive function\n\n\t}, enumerable: false, writable: true\n});\nObject.defineProperty(TargetArray.prototype, methodName, {\n\tvalue: function( callback, limit ) {\n\t\tlet array = this;\t\t// arrays are kept as is\n\n\t\treturn iterate( callback, array, limit );\n\n\t}, enumerable: true, writable: true\n});\n\n/**\n * Recursive function that iterates through\n * an array either in full or up to the set\n * limit of iterations\n * @param {function} callback\n * @param {array} array\n * @param {number} limit\n */\nfunction iterate( callback, array, limit=null ) {\n\tlet length = array.length;\n\tconst count = length < limit ? length : limit || length ;\t// iteration count\n\tlet i = 0;\n\n\tfunction next() {\n\t\tlet [ entry, entry2=undefined ] = Array.isArray(array[i]) ? array[i] : [array[i]];\n\t\tif ( i++ >= count ) { return }\n\n\t\t// value, index, key because it's seems easier to handle atm\n\t\treturn ( callback( entry2 || entry, i, entry2 && entry ), next() );\n\t}\t// Give it a push\n\tnext();\n}"]},"metadata":{},"sourceType":"module"}