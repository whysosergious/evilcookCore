{"ast":null,"code":"import _classCallCheck from \"C:/webWork/olivertwist/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _regeneratorRuntime from \"C:/webWork/olivertwist/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/webWork/olivertwist/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"C:/webWork/olivertwist/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\r\n * Collect hooks, references and other needed data that can be accessed wherever it's imported.\r\n * Names, structure and methods are all still WIP. As this is the first iteration of the\r\n * the module.\r\n */\nimport { useEffect, useState } from 'react'; // global data, references, functions and hooks\n\nexport var globalObj = {};\n\nglobalObj.getOffsets = function (group) {\n  Object.values(this[group]).forEach(function (e) {\n    return e.getOffsetY();\n  });\n}; // blueprint of method object that's copied and merged with the reference object\n\n\nvar globalObjMethods = {\n  // ref offset getter\n  getOffsetY: function getOffsetY() {\n    this.offsetY = this.ref.offsetTop;\n  },\n  init: function init(group, key, state, dispatch) {\n    // initial method with hook assignment\n    if (this.ref) {\n      this.ref = this.ref.current; // element reference\n\n      this.ref.zKey = key[0];\n      this.ref.zEl = this; // for easy pairing and execution of dispatch with observer ***check memory usage***\n\n      this.getOffsetY();\n    }\n\n    this.state = state; // component 'state'\n\n    this.setState = dispatch; // component hook 'setState'\n  }\n};\n/**\r\n * Global assignment of custom hooks for individual elements\r\n * @param {React.ElementRef<HTMLElement>} objectEntry\r\n */\n\nexport var useGlobalObj = function useGlobalObj(objectEntry) {\n  var group = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var key = Object.keys(objectEntry);\n\n  var _useState = useState(objectEntry[key].initialState || null),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1]; // custom hook\n  // when components mounts, we create their object entry\n  // and initialize the object\n\n\n  useEffect(function () {\n    // we check if the group property is defined and if that group already exist in the global object\n    globalObj[group || key] = globalObj[group] || {};\n    Object.assign(objectEntry[key], globalObjMethods);\n    objectEntry[key].init(group, key, state, setState);\n    Object.assign(globalObj[group || key], group ? objectEntry : objectEntry[key]);\n  }, []);\n  return [state, setState];\n};\n/**\r\n * Known issue **\r\n *\r\n * Currently a few component references are not initialized when root is mounted.\r\n * Requiring recalculation of element offsets. And while we can get them every time directly from the\r\n * references, those are reads we can spare the browser.\r\n * We can otherwise get them individually once at the start, and then on known changes.\r\n */\n\n/**\r\n * ********\tObserver & async raf\r\n * ****************************************************************\r\n */\n\n/**\r\n* Intersection Observer and async raf. Needs cleanup and documentation.\r\n*/\n\nvar rafTick = false;\nvar rafQueue = [];\n/**\r\n * Execute a function or method (or set a state)\r\n * TODO!: Creating a queue array that removes duplicate or unneeded action and executes\r\n * the rest in order\r\n * @param {Function} action\r\n */\n\nexport var queueFrame = function queueFrame(action) {\n  action = typeof action !== 'function' ? function () {\n    return action;\n  } : action; // we need a function\n\n  rafQueue.push(action); // add to queue\n\n  var nextRequest = function nextRequest() {\n    var count = rafQueue.length;\n    return new Promise(function (res, rej) {\n      window.requestAnimationFrame(function () {\n        for (var i = 0; i < count; i++) {\n          rafQueue[i]();\n        }\n\n        rafQueue.splice(0, count);\n        res('done');\n      });\n    });\n  };\n\n  var raf = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return nextRequest().then(function (v) {\n                rafQueue.length > 0 ? raf() : rafTick = false;\n                ;\n              });\n\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function raf() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  if (!rafTick) {\n    raf();\n    rafTick = true;\n  }\n}; // Object for separation of target values\n\nglobalObj.Observers = {};\n\nvar TargetClass = function TargetClass(target, handler) {\n  _classCallCheck(this, TargetClass);\n\n  this.prevRatio = 1.0;\n  this.elRef = target;\n  this.handler = handler;\n};\n/**\r\n * handy little function for defining different levels of thresholds\r\n * returns an int array\r\n * @param {BigInt} steps\r\n */\n\n\nvar buildThresholdList = function buildThresholdList(steps) {\n  var thresholds = [];\n  var numSteps = steps;\n\n  for (var i = 1.0; i <= numSteps; i++) {\n    var ratio = i / numSteps;\n    thresholds.push(ratio);\n  }\n\n  thresholds.push(0);\n  return thresholds;\n};\n\nfunction observeElement(targets) {\n  var _this = this;\n\n  // creating separate object for each target\n  var targetsArray = Array.isArray(targets) ? targets : [targets];\n  targetsArray.forEach(function (tgt) {\n    _this.observe(tgt);\n\n    _this.ObserverTargets[tgt.zKey] = new TargetClass(tgt, _this.handler);\n  });\n} // intersection observer\n\n\nexport var createObserver = function createObserver(name, root, targets, handler) {\n  var rootMargin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['0px 0px 0px 0px'];\n  var thresholdSteps = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 20;\n  var delay = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var originalHandler = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var observer;\n  var ModuleOptions = {\n    delay: delay,\n    root: root,\n    rootMargin: rootMargin,\n    threshold: buildThresholdList(thresholdSteps)\n  };\n  /**\r\n   * Shortening syntax and adding values\r\n   * has a callback pointing toward the assigned handler\r\n   * @param {*} entries\r\n   * @param {*} observer\r\n   */\n\n  var ModuleHandleIntersect = function ModuleHandleIntersect(entries, observer) {\n    entries.forEach(function (entry) {\n      var zKey = entry.target.zKey;\n      var prevRatio = observer.ObserverTargets[zKey].prevRatio;\n      observer.ObserverTargets[zKey].prevRatio = entry.intersectionRatio;\n      return observer.ObserverTargets[zKey].handler({\n        entry: entry,\n        observer: observer,\n        zKey: zKey,\n        prevRatio: prevRatio,\n        entries: entries\n      });\n    });\n  };\n\n  observer = new IntersectionObserver(originalHandler ? handler : ModuleHandleIntersect, ModuleOptions);\n  observer.handler = handler;\n  observer.ObserverTargets = {};\n  observer.observeElement = observeElement;\n  observer.observeElement(targets);\n  globalObj.Observers[name] = observer;\n};\n/**\r\n * NOTES **\r\n *\r\n * target.classList.add('stuck');\r\n * isInViewCol[zKey].set(true);\t// hooks were less performant by almost half( 653ms in just scripting )\r\n * of course refs should be used sparingly. But mixing css & js animation seems to work great!\r\n * plus, intersectionObserver completely eliminates the need to handle event listeners..\r\n * Not that event listeners don't have their use anymore.\r\n */\n\n/**\r\n * queueFrame() executes passed function or sets value asynchronously through a raf.\r\n * Queueing actions in array until they are run or applied. Though I need to find a different\r\n * way of triggering css as using custom hooks doesn't yield a lot because hooks are in\r\n * themselves asynchronous.\r\n * Recorded a 55% performance boost when triggering through 'ref.classList'.\r\n * ( 1057ms in only scripting, hard to compare to previous benchmarks though as the\r\n * workload was significantly different )\r\n * While refs are imperative, most React animation libraries use them and as previously stated\r\n * references are required for the use of 'intersectionObserver'.\r\n * The important thing to keep in mind is, when using classes, that changes are reset\r\n * when components rerender.\r\n * Which has many workarounds.\r\n */","map":{"version":3,"sources":["C:/webWork/olivertwist/node_modules/zergski-global/index.js"],"names":["useEffect","useState","globalObj","getOffsets","group","Object","values","forEach","e","getOffsetY","globalObjMethods","offsetY","ref","offsetTop","init","key","state","dispatch","current","zKey","zEl","setState","useGlobalObj","objectEntry","keys","initialState","assign","rafTick","rafQueue","queueFrame","action","push","nextRequest","count","length","Promise","res","rej","window","requestAnimationFrame","i","splice","raf","then","v","Observers","TargetClass","target","handler","prevRatio","elRef","buildThresholdList","steps","thresholds","numSteps","ratio","observeElement","targets","targetsArray","Array","isArray","tgt","observe","ObserverTargets","createObserver","name","root","rootMargin","thresholdSteps","delay","originalHandler","observer","ModuleOptions","threshold","ModuleHandleIntersect","entries","entry","intersectionRatio","IntersectionObserver"],"mappings":"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","sourcesContent":["/**\r\n * Collect hooks, references and other needed data that can be accessed wherever it's imported.\r\n * Names, structure and methods are all still WIP. As this is the first iteration of the\r\n * the module.\r\n */\r\nimport { useEffect, useState } from 'react';\r\n\r\n// global data, references, functions and hooks\r\nexport const globalObj = {};\r\nglobalObj.getOffsets = function(group) {\r\n\tObject.values(this[group]).forEach( e => e.getOffsetY());\r\n}\r\n// blueprint of method object that's copied and merged with the reference object\r\nconst globalObjMethods = {\r\n\t// ref offset getter\r\n\tgetOffsetY() {\r\n\t\tthis.offsetY = this.ref.offsetTop;\r\n\t},\r\n\tinit( group, key, state, dispatch ) {\t\t// initial method with hook assignment\r\n\t\tif ( this.ref ) {\r\n\t\t\tthis.ref = this.ref.current; \t// element reference\r\n\t\t\tthis.ref.zKey = key[0];\r\n\t\t\tthis.ref.zEl = this;\t\t// for easy pairing and execution of dispatch with observer ***check memory usage***\r\n\t\t\tthis.getOffsetY();\r\n\t\t}\r\n\t\tthis.state = state;\t\t// component 'state'\r\n\t\tthis.setState = dispatch;\t\t// component hook 'setState'\r\n\t},\r\n}\r\n\r\n/**\r\n * Global assignment of custom hooks for individual elements\r\n * @param {React.ElementRef<HTMLElement>} objectEntry\r\n */\r\nexport const useGlobalObj = ( objectEntry, group = null) => {\r\n\tlet key = Object.keys( objectEntry );\r\n\tconst [ state, setState ] = useState(objectEntry[key].initialState || null);\t// custom hook\r\n\t// when components mounts, we create their object entry\r\n\t// and initialize the object\r\n\r\n\tuseEffect(() => {\r\n\t\t// we check if the group property is defined and if that group already exist in the global object\r\n\t\tglobalObj[group || key] = globalObj[group] || {};\r\n\r\n\t\tObject.assign( objectEntry[key], globalObjMethods );\r\n\t\tobjectEntry[key].init( group, key, state, setState );\r\n\t\tObject.assign( globalObj[group || key], group ? objectEntry : objectEntry[key]  );\r\n\r\n\t}, []);\r\n\r\n\treturn [ state, setState ];\r\n}\r\n\r\n\r\n/**\r\n * Known issue **\r\n *\r\n * Currently a few component references are not initialized when root is mounted.\r\n * Requiring recalculation of element offsets. And while we can get them every time directly from the\r\n * references, those are reads we can spare the browser.\r\n * We can otherwise get them individually once at the start, and then on known changes.\r\n */\r\n\r\n\r\n\r\n /**\r\n  * ********\tObserver & async raf\r\n  * ****************************************************************\r\n  */\r\n  /**\r\n * Intersection Observer and async raf. Needs cleanup and documentation.\r\n */\r\n\r\nlet rafTick = false;\r\nconst rafQueue = [];\r\n/**\r\n * Execute a function or method (or set a state)\r\n * TODO!: Creating a queue array that removes duplicate or unneeded action and executes\r\n * the rest in order\r\n * @param {Function} action\r\n */\r\nexport const queueFrame = action => {\r\n\taction = typeof action !== 'function' ? (() => action) : action;\t// we need a function\r\n\trafQueue.push(action);\t// add to queue\r\n\r\n\tconst nextRequest = () => {\r\n\t\tlet count = rafQueue.length;\r\n\t\treturn new Promise(( res, rej ) => {\r\n\t\t\twindow.requestAnimationFrame(() => {\r\n\t\t\t\tfor ( let i=0; i<count; i++ ) {\r\n\t\t\t\t\trafQueue[i]();\r\n\t\t\t\t}\r\n\t\t\t\trafQueue.splice(0, count);\r\n\t\t\t\tres('done');\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\tconst raf = async () => {\r\n\t\tawait nextRequest().then(v => {\r\n\t\t\trafQueue.length > 0 ? raf() : rafTick = false;;\r\n\t\t});\r\n\t};\r\n\r\n\tif (!rafTick) {\r\n\t\traf();\r\n\t\trafTick = true;\r\n\t}\r\n}\r\n\r\n// Object for separation of target values\r\nglobalObj.Observers = {};\r\nclass TargetClass {\r\n\tconstructor( target, handler ) {\r\n\t\tthis.prevRatio = 1.0;\r\n\t\tthis.elRef = target;\r\n\t\tthis.handler = handler;\r\n\t}\r\n}\r\n\r\n/**\r\n * handy little function for defining different levels of thresholds\r\n * returns an int array\r\n * @param {BigInt} steps\r\n */\r\nconst buildThresholdList = ( steps ) => {\r\n\tlet thresholds = [];\r\n\tlet numSteps = steps;\r\n\r\n\tfor (let i=1.0; i<=numSteps; i++) {\r\n\t\tlet ratio = i/numSteps;\r\n\t\tthresholds.push(ratio);\r\n\t}\r\n\r\n\tthresholds.push(0);\r\n\treturn thresholds;\r\n}\r\n\r\nfunction observeElement( targets ) {\r\n\t// creating separate object for each target\r\n\tlet targetsArray = Array.isArray( targets ) ? targets : [ targets ];\r\n\ttargetsArray.forEach( tgt => {\r\n\t\tthis.observe( tgt );\r\n\t\tthis.ObserverTargets[tgt.zKey] = new TargetClass( tgt, this.handler );\r\n\t});\r\n}\r\n\r\n// intersection observer\r\nexport const createObserver = ( name, root, targets, handler, rootMargin=['0px 0px 0px 0px'], thresholdSteps=20, delay=0, originalHandler=false ) => {\r\n\tlet observer;\r\n\r\n\tlet ModuleOptions = {\r\n\t\tdelay: delay,\r\n\t\troot: root,\r\n\t\trootMargin: rootMargin,\r\n\t\tthreshold: buildThresholdList(thresholdSteps),\r\n\t};\r\n\r\n\t/**\r\n\t * Shortening syntax and adding values\r\n\t * has a callback pointing toward the assigned handler\r\n\t * @param {*} entries\r\n\t * @param {*} observer\r\n\t */\r\n\tconst ModuleHandleIntersect = ( entries, observer ) => {\r\n\t\tentries.forEach( entry => {\r\n\t\t\tlet { zKey } = entry.target;\r\n\t\t\tlet prevRatio = observer.ObserverTargets[zKey].prevRatio;\r\n\r\n\t\t\tobserver.ObserverTargets[zKey].prevRatio = entry.intersectionRatio;\r\n\t\t\treturn observer.ObserverTargets[zKey].handler({ entry, observer, zKey, prevRatio, entries });\r\n\t\t});\r\n\t}\r\n\r\n\tobserver = new IntersectionObserver( originalHandler ? handler : ModuleHandleIntersect , ModuleOptions );\r\n\r\n\tobserver.handler = handler;\r\n\tobserver.ObserverTargets = {};\r\n\tobserver.observeElement = observeElement;\r\n\tobserver.observeElement( targets );\r\n\r\n\tglobalObj.Observers[name] = observer;\r\n}\r\n\r\n\r\n/**\r\n * NOTES **\r\n *\r\n * target.classList.add('stuck');\r\n * isInViewCol[zKey].set(true);\t// hooks were less performant by almost half( 653ms in just scripting )\r\n * of course refs should be used sparingly. But mixing css & js animation seems to work great!\r\n * plus, intersectionObserver completely eliminates the need to handle event listeners..\r\n * Not that event listeners don't have their use anymore.\r\n */\r\n\r\n\r\n\r\n /**\r\n  * queueFrame() executes passed function or sets value asynchronously through a raf.\r\n  * Queueing actions in array until they are run or applied. Though I need to find a different\r\n  * way of triggering css as using custom hooks doesn't yield a lot because hooks are in\r\n  * themselves asynchronous.\r\n  * Recorded a 55% performance boost when triggering through 'ref.classList'.\r\n  * ( 1057ms in only scripting, hard to compare to previous benchmarks though as the\r\n  * workload was significantly different )\r\n  * While refs are imperative, most React animation libraries use them and as previously stated\r\n  * references are required for the use of 'intersectionObserver'.\r\n  * The important thing to keep in mind is, when using classes, that changes are reset\r\n  * when components rerender.\r\n  * Which has many workarounds.\r\n  */"]},"metadata":{},"sourceType":"module"}