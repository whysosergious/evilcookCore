{"ast":null,"code":"/**\r\n * Collect hooks, references and other needed data that can be accessed wherever it's imported.\r\n * Names, structure and methods are all still WIP. As this is the first iteration of the\r\n * the module.\r\n */\nimport { useEffect, useState } from 'react'; // global data, references, functions and hooks\n\nexport const globalObj = {};\n\nglobalObj.getOffsets = function (group) {\n  Object.values(this[group]).forEach(e => e.getOffsetY());\n}; // blueprint of method object that's copied and merged with the reference object\n\n\nconst globalObjMethods = {\n  // ref offset getter\n  getOffsetY() {\n    this.offsetY = this.ref.offsetTop;\n  },\n\n  init(group, key, state, dispatch) {\n    // initial method with hook assignment\n    if (this.ref) {\n      this.ref = this.ref.current; // element reference\n\n      this.ref.zKey = key[0];\n      this.ref.zEl = this; // for easy pairing and execution of dispatch with observer ***check memory usage***\n\n      this.getOffsetY();\n    }\n\n    this.state = state; // component 'state'\n\n    this.setState = dispatch; // component hook 'setState'\n  }\n\n};\n/**\r\n * Global assignment of custom hooks for individual elements\r\n * @param {React.ElementRef<HTMLElement>} objectEntry\r\n */\n\nexport const useGlobalObj = (objectEntry, group = null) => {\n  let key = Object.keys(objectEntry);\n  const [state, setState] = useState(objectEntry[key].initialState || null); // custom hook\n  // when components mounts, we create their object entry\n  // and initialize the object\n\n  useEffect(() => {\n    // we check if the group property is defined and if that group already exist in the global object\n    globalObj[group || key] = globalObj[group] || {};\n    Object.assign(objectEntry[key], globalObjMethods);\n    objectEntry[key].init(group, key, state, setState);\n    Object.assign(globalObj[group || key], group ? objectEntry : objectEntry[key]);\n  }, []);\n  return [state, setState];\n};\n/**\r\n * Known issue **\r\n *\r\n * Currently a few component references are not initialized when root is mounted.\r\n * Requiring recalculation of element offsets. And while we can get them every time directly from the\r\n * references, those are reads we can spare the browser.\r\n * We can otherwise get them individually once at the start, and then on known changes.\r\n */\n\n/**\r\n * ********\tObserver & async raf\r\n * ****************************************************************\r\n */\n\n/**\r\n* Intersection Observer and async raf. Needs cleanup and documentation.\r\n*/\n\nlet rafTick = false;\nconst rafQueue = [];\n/**\r\n * Execute a function or method (or set a state)\r\n * TODO!: Creating a queue array that removes duplicate or unneeded action and executes\r\n * the rest in order\r\n * @param {Function} action\r\n */\n\nexport const queueFrame = action => {\n  action = typeof action !== 'function' ? () => action : action; // we need a function\n\n  rafQueue.push(action); // add to queue\n\n  const nextRequest = () => {\n    let count = rafQueue.length;\n    return new Promise((res, rej) => {\n      window.requestAnimationFrame(() => {\n        for (let i = 0; i < count; i++) {\n          rafQueue[i]();\n        }\n\n        rafQueue.splice(0, count);\n        res('done');\n      });\n    });\n  };\n\n  const raf = async () => {\n    await nextRequest().then(v => {\n      rafQueue.length > 0 ? raf() : rafTick = false;\n      ;\n    });\n  };\n\n  if (!rafTick) {\n    raf();\n    rafTick = true;\n  }\n}; // Object for separation of target values\n\nglobalObj.Observers = {};\n\nclass TargetClass {\n  constructor(target, handler) {\n    this.prevRatio = 1.0;\n    this.elRef = target;\n    this.handler = handler;\n  }\n\n}\n/**\r\n * handy little function for defining different levels of thresholds\r\n * returns an int array\r\n * @param {BigInt} steps\r\n */\n\n\nconst buildThresholdList = steps => {\n  let thresholds = [];\n  let numSteps = steps;\n\n  for (let i = 1.0; i <= numSteps; i++) {\n    let ratio = i / numSteps;\n    thresholds.push(ratio);\n  }\n\n  thresholds.push(0);\n  return thresholds;\n};\n\nfunction observeElement(targets) {\n  // creating separate object for each target\n  let targetsArray = Array.isArray(targets) ? targets : [targets];\n  targetsArray.forEach(tgt => {\n    this.observe(tgt);\n    this.ObserverTargets[tgt.zKey] = new TargetClass(tgt, this.handler);\n  });\n} // intersection observer\n\n\nexport const createObserver = (name, root, targets, handler, rootMargin = ['0px 0px 0px 0px'], thresholdSteps = 20, delay = 0, originalHandler = false) => {\n  let observer;\n  let ModuleOptions = {\n    delay: delay,\n    root: root,\n    rootMargin: rootMargin,\n    threshold: buildThresholdList(thresholdSteps)\n  };\n  /**\r\n   * Shortening syntax and adding values\r\n   * has a callback pointing toward the assigned handler\r\n   * @param {*} entries\r\n   * @param {*} observer\r\n   */\n\n  const ModuleHandleIntersect = (entries, observer) => {\n    entries.forEach(entry => {\n      let {\n        zKey\n      } = entry.target;\n      let prevRatio = observer.ObserverTargets[zKey].prevRatio;\n      observer.ObserverTargets[zKey].prevRatio = entry.intersectionRatio;\n      return observer.ObserverTargets[zKey].handler({\n        entry,\n        observer,\n        zKey,\n        prevRatio,\n        entries\n      });\n    });\n  };\n\n  observer = new IntersectionObserver(originalHandler ? handler : ModuleHandleIntersect, ModuleOptions);\n  observer.handler = handler;\n  observer.ObserverTargets = {};\n  observer.observeElement = observeElement;\n  observer.observeElement(targets);\n  globalObj.Observers[name] = observer;\n};\n/**\r\n * NOTES **\r\n *\r\n * target.classList.add('stuck');\r\n * isInViewCol[zKey].set(true);\t// hooks were less performant by almost half( 653ms in just scripting )\r\n * of course refs should be used sparingly. But mixing css & js animation seems to work great!\r\n * plus, intersectionObserver completely eliminates the need to handle event listeners..\r\n * Not that event listeners don't have their use anymore.\r\n */\n\n/**\r\n * queueFrame() executes passed function or sets value asynchronously through a raf.\r\n * Queueing actions in array until they are run or applied. Though I need to find a different\r\n * way of triggering css as using custom hooks doesn't yield a lot because hooks are in\r\n * themselves asynchronous.\r\n * Recorded a 55% performance boost when triggering through 'ref.classList'.\r\n * ( 1057ms in only scripting, hard to compare to previous benchmarks though as the\r\n * workload was significantly different )\r\n * While refs are imperative, most React animation libraries use them and as previously stated\r\n * references are required for the use of 'intersectionObserver'.\r\n * The important thing to keep in mind is, when using classes, that changes are reset\r\n * when components rerender.\r\n * Which has many workarounds.\r\n */","map":{"version":3,"sources":["C:/webWork/evilcook/node_modules/zergski-global/index.js"],"names":["useEffect","useState","globalObj","getOffsets","group","Object","values","forEach","e","getOffsetY","globalObjMethods","offsetY","ref","offsetTop","init","key","state","dispatch","current","zKey","zEl","setState","useGlobalObj","objectEntry","keys","initialState","assign","rafTick","rafQueue","queueFrame","action","push","nextRequest","count","length","Promise","res","rej","window","requestAnimationFrame","i","splice","raf","then","v","Observers","TargetClass","constructor","target","handler","prevRatio","elRef","buildThresholdList","steps","thresholds","numSteps","ratio","observeElement","targets","targetsArray","Array","isArray","tgt","observe","ObserverTargets","createObserver","name","root","rootMargin","thresholdSteps","delay","originalHandler","observer","ModuleOptions","threshold","ModuleHandleIntersect","entries","entry","intersectionRatio","IntersectionObserver"],"mappings":"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","sourcesContent":["/**\r\n * Collect hooks, references and other needed data that can be accessed wherever it's imported.\r\n * Names, structure and methods are all still WIP. As this is the first iteration of the\r\n * the module.\r\n */\r\nimport { useEffect, useState } from 'react';\r\n\r\n// global data, references, functions and hooks\r\nexport const globalObj = {};\r\nglobalObj.getOffsets = function(group) {\r\n\tObject.values(this[group]).forEach( e => e.getOffsetY());\r\n}\r\n// blueprint of method object that's copied and merged with the reference object\r\nconst globalObjMethods = {\r\n\t// ref offset getter\r\n\tgetOffsetY() {\r\n\t\tthis.offsetY = this.ref.offsetTop;\r\n\t},\r\n\tinit( group, key, state, dispatch ) {\t\t// initial method with hook assignment\r\n\t\tif ( this.ref ) {\r\n\t\t\tthis.ref = this.ref.current; \t// element reference\r\n\t\t\tthis.ref.zKey = key[0];\r\n\t\t\tthis.ref.zEl = this;\t\t// for easy pairing and execution of dispatch with observer ***check memory usage***\r\n\t\t\tthis.getOffsetY();\r\n\t\t}\r\n\t\tthis.state = state;\t\t// component 'state'\r\n\t\tthis.setState = dispatch;\t\t// component hook 'setState'\r\n\t},\r\n}\r\n\r\n/**\r\n * Global assignment of custom hooks for individual elements\r\n * @param {React.ElementRef<HTMLElement>} objectEntry\r\n */\r\nexport const useGlobalObj = ( objectEntry, group = null) => {\r\n\tlet key = Object.keys( objectEntry );\r\n\tconst [ state, setState ] = useState(objectEntry[key].initialState || null);\t// custom hook\r\n\t// when components mounts, we create their object entry\r\n\t// and initialize the object\r\n\r\n\tuseEffect(() => {\r\n\t\t// we check if the group property is defined and if that group already exist in the global object\r\n\t\tglobalObj[group || key] = globalObj[group] || {};\r\n\r\n\t\tObject.assign( objectEntry[key], globalObjMethods );\r\n\t\tobjectEntry[key].init( group, key, state, setState );\r\n\t\tObject.assign( globalObj[group || key], group ? objectEntry : objectEntry[key]  );\r\n\r\n\t}, []);\r\n\r\n\treturn [ state, setState ];\r\n}\r\n\r\n\r\n/**\r\n * Known issue **\r\n *\r\n * Currently a few component references are not initialized when root is mounted.\r\n * Requiring recalculation of element offsets. And while we can get them every time directly from the\r\n * references, those are reads we can spare the browser.\r\n * We can otherwise get them individually once at the start, and then on known changes.\r\n */\r\n\r\n\r\n\r\n /**\r\n  * ********\tObserver & async raf\r\n  * ****************************************************************\r\n  */\r\n  /**\r\n * Intersection Observer and async raf. Needs cleanup and documentation.\r\n */\r\n\r\nlet rafTick = false;\r\nconst rafQueue = [];\r\n/**\r\n * Execute a function or method (or set a state)\r\n * TODO!: Creating a queue array that removes duplicate or unneeded action and executes\r\n * the rest in order\r\n * @param {Function} action\r\n */\r\nexport const queueFrame = action => {\r\n\taction = typeof action !== 'function' ? (() => action) : action;\t// we need a function\r\n\trafQueue.push(action);\t// add to queue\r\n\r\n\tconst nextRequest = () => {\r\n\t\tlet count = rafQueue.length;\r\n\t\treturn new Promise(( res, rej ) => {\r\n\t\t\twindow.requestAnimationFrame(() => {\r\n\t\t\t\tfor ( let i=0; i<count; i++ ) {\r\n\t\t\t\t\trafQueue[i]();\r\n\t\t\t\t}\r\n\t\t\t\trafQueue.splice(0, count);\r\n\t\t\t\tres('done');\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\tconst raf = async () => {\r\n\t\tawait nextRequest().then(v => {\r\n\t\t\trafQueue.length > 0 ? raf() : rafTick = false;;\r\n\t\t});\r\n\t};\r\n\r\n\tif (!rafTick) {\r\n\t\traf();\r\n\t\trafTick = true;\r\n\t}\r\n}\r\n\r\n// Object for separation of target values\r\nglobalObj.Observers = {};\r\nclass TargetClass {\r\n\tconstructor( target, handler ) {\r\n\t\tthis.prevRatio = 1.0;\r\n\t\tthis.elRef = target;\r\n\t\tthis.handler = handler;\r\n\t}\r\n}\r\n\r\n/**\r\n * handy little function for defining different levels of thresholds\r\n * returns an int array\r\n * @param {BigInt} steps\r\n */\r\nconst buildThresholdList = ( steps ) => {\r\n\tlet thresholds = [];\r\n\tlet numSteps = steps;\r\n\r\n\tfor (let i=1.0; i<=numSteps; i++) {\r\n\t\tlet ratio = i/numSteps;\r\n\t\tthresholds.push(ratio);\r\n\t}\r\n\r\n\tthresholds.push(0);\r\n\treturn thresholds;\r\n}\r\n\r\nfunction observeElement( targets ) {\r\n\t// creating separate object for each target\r\n\tlet targetsArray = Array.isArray( targets ) ? targets : [ targets ];\r\n\ttargetsArray.forEach( tgt => {\r\n\t\tthis.observe( tgt );\r\n\t\tthis.ObserverTargets[tgt.zKey] = new TargetClass( tgt, this.handler );\r\n\t});\r\n}\r\n\r\n// intersection observer\r\nexport const createObserver = ( name, root, targets, handler, rootMargin=['0px 0px 0px 0px'], thresholdSteps=20, delay=0, originalHandler=false ) => {\r\n\tlet observer;\r\n\r\n\tlet ModuleOptions = {\r\n\t\tdelay: delay,\r\n\t\troot: root,\r\n\t\trootMargin: rootMargin,\r\n\t\tthreshold: buildThresholdList(thresholdSteps),\r\n\t};\r\n\r\n\t/**\r\n\t * Shortening syntax and adding values\r\n\t * has a callback pointing toward the assigned handler\r\n\t * @param {*} entries\r\n\t * @param {*} observer\r\n\t */\r\n\tconst ModuleHandleIntersect = ( entries, observer ) => {\r\n\t\tentries.forEach( entry => {\r\n\t\t\tlet { zKey } = entry.target;\r\n\t\t\tlet prevRatio = observer.ObserverTargets[zKey].prevRatio;\r\n\r\n\t\t\tobserver.ObserverTargets[zKey].prevRatio = entry.intersectionRatio;\r\n\t\t\treturn observer.ObserverTargets[zKey].handler({ entry, observer, zKey, prevRatio, entries });\r\n\t\t});\r\n\t}\r\n\r\n\tobserver = new IntersectionObserver( originalHandler ? handler : ModuleHandleIntersect , ModuleOptions );\r\n\r\n\tobserver.handler = handler;\r\n\tobserver.ObserverTargets = {};\r\n\tobserver.observeElement = observeElement;\r\n\tobserver.observeElement( targets );\r\n\r\n\tglobalObj.Observers[name] = observer;\r\n}\r\n\r\n\r\n/**\r\n * NOTES **\r\n *\r\n * target.classList.add('stuck');\r\n * isInViewCol[zKey].set(true);\t// hooks were less performant by almost half( 653ms in just scripting )\r\n * of course refs should be used sparingly. But mixing css & js animation seems to work great!\r\n * plus, intersectionObserver completely eliminates the need to handle event listeners..\r\n * Not that event listeners don't have their use anymore.\r\n */\r\n\r\n\r\n\r\n /**\r\n  * queueFrame() executes passed function or sets value asynchronously through a raf.\r\n  * Queueing actions in array until they are run or applied. Though I need to find a different\r\n  * way of triggering css as using custom hooks doesn't yield a lot because hooks are in\r\n  * themselves asynchronous.\r\n  * Recorded a 55% performance boost when triggering through 'ref.classList'.\r\n  * ( 1057ms in only scripting, hard to compare to previous benchmarks though as the\r\n  * workload was significantly different )\r\n  * While refs are imperative, most React animation libraries use them and as previously stated\r\n  * references are required for the use of 'intersectionObserver'.\r\n  * The important thing to keep in mind is, when using classes, that changes are reset\r\n  * when components rerender.\r\n  * Which has many workarounds.\r\n  */"]},"metadata":{},"sourceType":"module"}