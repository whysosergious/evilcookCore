{"ast":null,"code":"/**\n * Intersection Observer and async raf. Needs cleanup and documentation.\n */\nimport { globalObj } from 'logic/zergski-global-object';\nlet rafTick = false;\nconst rafQueue = [];\n/**\n * Execute a function or method (or set a state)\n * TODO!: Creating a queue array that removes duplicate or unneeded action and executes\n * the rest in order\n * @param {Function} action\n */\n\nexport const queueFrame = action => {\n  action = typeof action !== 'function' ? () => action : action; // we need a function\n\n  rafQueue.push(action); // add to queue\n\n  const nextRequest = () => {\n    let count = rafQueue.length;\n    return new Promise((res, rej) => {\n      window.requestAnimationFrame(() => {\n        for (let i = 0; i < count; i++) {\n          rafQueue[i]();\n        }\n\n        rafQueue.splice(0, count);\n        res('done');\n      });\n    });\n  };\n\n  const raf = async () => {\n    await nextRequest().then(v => {\n      rafQueue.length > 0 ? raf() : rafTick = false;\n      ;\n    });\n  };\n\n  if (!rafTick) {\n    raf();\n    rafTick = true;\n  }\n}; // Object for separation of target values\n\nglobalObj.Observers = {};\n\nclass TargetClass {\n  constructor(target, handler) {\n    this.prevRatio = 1.0;\n    this.elRef = target;\n    this.handler = handler;\n  }\n\n}\n/**\n * handy little function for defining different levels of thresholds\n * returns an int array\n * @param {BigInt} steps\n */\n\n\nconst buildThresholdList = steps => {\n  let thresholds = [];\n  let numSteps = steps;\n\n  for (let i = 1.0; i <= numSteps; i++) {\n    let ratio = i / numSteps;\n    thresholds.push(ratio);\n  }\n\n  thresholds.push(0);\n  return thresholds;\n};\n\nfunction observeElement(targets) {\n  // creating separate object for each target\n  let targetsArray = Array.isArray(targets) ? targets : [targets];\n  targetsArray.forEach(tgt => {\n    this.observe(tgt);\n    this.ObserverTargets[tgt.zKey] = new TargetClass(tgt, this.handler);\n  });\n} // intersection observer\n\n\nconst createObserver = (name, root, targets, handler, rootMargin = ['0px 0px 0px 0px'], thresholdSteps = 20, delay = 0, originalHandler = false) => {\n  let observer;\n  let ModuleOptions = {\n    delay: delay,\n    root: root,\n    rootMargin: rootMargin,\n    threshold: buildThresholdList(thresholdSteps)\n  };\n  /**\n   * Shortening syntax and adding values\n   * has a callback pointing toward the assigned handler\n   * @param {*} entries\n   * @param {*} observer\n   */\n\n  const ModuleHandleIntersect = (entries, observer) => {\n    entries.forEach(entry => {\n      let {\n        zKey\n      } = entry.target;\n      let prevRatio = observer.ObserverTargets[zKey].prevRatio;\n      observer.ObserverTargets[zKey].prevRatio = entry.intersectionRatio;\n      return observer.ObserverTargets[zKey].handler({\n        entry,\n        observer,\n        zKey,\n        prevRatio,\n        entries\n      });\n    });\n  };\n\n  observer = new IntersectionObserver(originalHandler ? handler : ModuleHandleIntersect, ModuleOptions);\n  observer.handler = handler;\n  observer.ObserverTargets = {};\n  observer.observeElement = observeElement;\n  observer.observeElement(targets);\n  globalObj.Observers[name] = observer;\n};\n\nexport { createObserver };\n/**\n * NOTES **\n *\n * target.classList.add('stuck');\n * isInViewCol[zKey].set(true);\t// hooks were less performant by almost half( 653ms in just scripting )\n * of course refs should be used sparingly. But mixing css & js animation seems to work great!\n * plus, intersectionObserver completely eliminates the need to handle event listeners..\n * Not that event listeners don't have their use anymore.\n */\n\n/**\n * queueFrame() executes passed function or sets value asynchronously through a raf.\n * Queueing actions in array until they are run or applied. Though I need to find a different\n * way of triggering css as using custom hooks doesn't yield a lot because hooks are in\n * themselves asynchronous.\n * Recorded a 55% performance boost when triggering through 'ref.classList'.\n * ( 1057ms in only scripting, hard to compare to previous benchmarks though as the\n * workload was significantly different )\n * While refs are imperative, most React animation libraries use them and as previously stated\n * references are required for the use of 'intersectionObserver'.\n * The important thing to keep in mind is, when using classes, that changes are reset\n * when components rerender.\n * Which has many workarounds.\n */","map":{"version":3,"sources":["C:/webWork/olivertwist/src/logic/zergski-intersection-observer.js"],"names":["globalObj","rafTick","rafQueue","queueFrame","action","push","nextRequest","count","length","Promise","res","rej","window","requestAnimationFrame","i","splice","raf","then","v","Observers","TargetClass","constructor","target","handler","prevRatio","elRef","buildThresholdList","steps","thresholds","numSteps","ratio","observeElement","targets","targetsArray","Array","isArray","forEach","tgt","observe","ObserverTargets","zKey","createObserver","name","root","rootMargin","thresholdSteps","delay","originalHandler","observer","ModuleOptions","threshold","ModuleHandleIntersect","entries","entry","intersectionRatio","IntersectionObserver"],"mappings":"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","sourcesContent":["/**\n * Intersection Observer and async raf. Needs cleanup and documentation.\n */\nimport { globalObj } from 'logic/zergski-global-object';\n\n\nlet rafTick = false;\nconst rafQueue = [];\n/**\n * Execute a function or method (or set a state)\n * TODO!: Creating a queue array that removes duplicate or unneeded action and executes\n * the rest in order\n * @param {Function} action\n */\nexport const queueFrame = action => {\n\taction = typeof action !== 'function' ? (() => action) : action;\t// we need a function\n\trafQueue.push(action);\t// add to queue\n\n\tconst nextRequest = () => {\n\t\tlet count = rafQueue.length;\n\t\treturn new Promise(( res, rej ) => {\n\t\t\twindow.requestAnimationFrame(() => {\n\t\t\t\tfor ( let i=0; i<count; i++ ) {\n\t\t\t\t\trafQueue[i]();\n\t\t\t\t}\n\t\t\t\trafQueue.splice(0, count);\n\t\t\t\tres('done');\n\t\t\t});\n\t\t});\n\t}\n\tconst raf = async () => {\n\t\tawait nextRequest().then(v => {\n\t\t\trafQueue.length > 0 ? raf() : rafTick = false;;\n\t\t});\n\t};\n\n\tif (!rafTick) {\n\t\traf();\n\t\trafTick = true;\n\t}\n}\n\n// Object for separation of target values\nglobalObj.Observers = {};\nclass TargetClass {\n\tconstructor( target, handler ) {\n\t\tthis.prevRatio = 1.0;\n\t\tthis.elRef = target;\n\t\tthis.handler = handler;\n\t}\n}\n\n/**\n * handy little function for defining different levels of thresholds\n * returns an int array\n * @param {BigInt} steps\n */\nconst buildThresholdList = ( steps ) => {\n\tlet thresholds = [];\n\tlet numSteps = steps;\n\n\tfor (let i=1.0; i<=numSteps; i++) {\n\t\tlet ratio = i/numSteps;\n\t\tthresholds.push(ratio);\n\t}\n\n\tthresholds.push(0);\n\treturn thresholds;\n}\n\nfunction observeElement( targets ) {\n\t// creating separate object for each target\n\tlet targetsArray = Array.isArray( targets ) ? targets : [ targets ];\n\ttargetsArray.forEach( tgt => {\n\t\tthis.observe( tgt );\n\t\tthis.ObserverTargets[tgt.zKey] = new TargetClass( tgt, this.handler );\n\t});\n}\n\n// intersection observer\nconst createObserver = ( name, root, targets, handler, rootMargin=['0px 0px 0px 0px'], thresholdSteps=20, delay=0, originalHandler=false ) => {\n\tlet observer;\n\n\tlet ModuleOptions = {\n\t\tdelay: delay,\n\t\troot: root,\n\t\trootMargin: rootMargin,\n\t\tthreshold: buildThresholdList(thresholdSteps),\n\t};\n\n\t/**\n\t * Shortening syntax and adding values\n\t * has a callback pointing toward the assigned handler\n\t * @param {*} entries\n\t * @param {*} observer\n\t */\n\tconst ModuleHandleIntersect = ( entries, observer ) => {\n\t\tentries.forEach( entry => {\n\t\t\tlet { zKey } = entry.target;\n\t\t\tlet prevRatio = observer.ObserverTargets[zKey].prevRatio;\n\n\t\t\tobserver.ObserverTargets[zKey].prevRatio = entry.intersectionRatio;\n\t\t\treturn observer.ObserverTargets[zKey].handler({ entry, observer, zKey, prevRatio, entries });\n\t\t});\n\t}\n\n\tobserver = new IntersectionObserver( originalHandler ? handler : ModuleHandleIntersect , ModuleOptions );\n\n\tobserver.handler = handler;\n\tobserver.ObserverTargets = {};\n\tobserver.observeElement = observeElement;\n\tobserver.observeElement( targets );\n\n\tglobalObj.Observers[name] = observer;\n}\n\nexport { createObserver };\n\n\n/**\n * NOTES **\n *\n * target.classList.add('stuck');\n * isInViewCol[zKey].set(true);\t// hooks were less performant by almost half( 653ms in just scripting )\n * of course refs should be used sparingly. But mixing css & js animation seems to work great!\n * plus, intersectionObserver completely eliminates the need to handle event listeners..\n * Not that event listeners don't have their use anymore.\n */\n\n\n\n /**\n  * queueFrame() executes passed function or sets value asynchronously through a raf.\n  * Queueing actions in array until they are run or applied. Though I need to find a different\n  * way of triggering css as using custom hooks doesn't yield a lot because hooks are in\n  * themselves asynchronous.\n  * Recorded a 55% performance boost when triggering through 'ref.classList'.\n  * ( 1057ms in only scripting, hard to compare to previous benchmarks though as the\n  * workload was significantly different )\n  * While refs are imperative, most React animation libraries use them and as previously stated\n  * references are required for the use of 'intersectionObserver'.\n  * The important thing to keep in mind is, when using classes, that changes are reset\n  * when components rerender.\n  * Which has many workarounds.\n  */"]},"metadata":{},"sourceType":"module"}