{"ast":null,"code":"import _classCallCheck from\"C:/webWork/olivertwist/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _regeneratorRuntime from\"C:/webWork/olivertwist/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"C:/webWork/olivertwist/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/**\n * Intersection Observer and async raf. Needs cleanup and documentation.\n */import{globalObj}from'logic/zergski-global-object';var rafTick=false;var rafQueue=[];/**\n * Execute a function or method (or set a state)\n * TODO!: Creating a queue array that removes duplicate or unneeded action and executes\n * the rest in order\n * @param {Function} action\n */export var queueFrame=function queueFrame(action){action=typeof action!=='function'?function(){return action;}:action;// we need a function\nrafQueue.push(action);// add to queue\nvar nextRequest=function nextRequest(){var count=rafQueue.length;return new Promise(function(res,rej){window.requestAnimationFrame(function(){for(var i=0;i<count;i++){rafQueue[i]();}rafQueue.splice(0,count);res('done');});});};var raf=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return nextRequest().then(function(v){rafQueue.length>0?raf():rafTick=false;;});case 2:case\"end\":return _context.stop();}}},_callee);}));return function raf(){return _ref.apply(this,arguments);};}();if(!rafTick){raf();rafTick=true;}};// Object for separation of target values\nglobalObj.Observers={};var TargetClass=function TargetClass(target,handler){_classCallCheck(this,TargetClass);this.prevRatio=1.0;this.elRef=target;this.handler=handler;};/**\n * handy little function for defining different levels of thresholds\n * returns an int array\n * @param {BigInt} steps\n */var buildThresholdList=function buildThresholdList(steps){var thresholds=[];var numSteps=steps;for(var i=1.0;i<=numSteps;i++){var ratio=i/numSteps;thresholds.push(ratio);}thresholds.push(0);return thresholds;};function observeElement(targets){var _this=this;// creating separate object for each target\nvar targetsArray=Array.isArray(targets)?targets:[targets];targetsArray.forEach(function(tgt){_this.observe(tgt);_this.ObserverTargets[tgt.zKey]=new TargetClass(tgt,_this.handler);});}// intersection observer\nvar createObserver=function createObserver(name,root,targets,handler){var rootMargin=arguments.length>4&&arguments[4]!==undefined?arguments[4]:['0px 0px 0px 0px'];var thresholdSteps=arguments.length>5&&arguments[5]!==undefined?arguments[5]:20;var delay=arguments.length>6&&arguments[6]!==undefined?arguments[6]:0;var originalHandler=arguments.length>7&&arguments[7]!==undefined?arguments[7]:false;var observer;var ModuleOptions={delay:delay,root:root,rootMargin:rootMargin,threshold:buildThresholdList(thresholdSteps)};/**\n\t * Shortening syntax and adding values\n\t * has a callback pointing toward the assigned handler\n\t * @param {*} entries\n\t * @param {*} observer\n\t */var ModuleHandleIntersect=function ModuleHandleIntersect(entries,observer){entries.forEach(function(entry){var zKey=entry.target.zKey;var prevRatio=observer.ObserverTargets[zKey].prevRatio;observer.ObserverTargets[zKey].prevRatio=entry.intersectionRatio;return observer.ObserverTargets[zKey].handler({entry:entry,observer:observer,zKey:zKey,prevRatio:prevRatio,entries:entries});});};observer=new IntersectionObserver(originalHandler?handler:ModuleHandleIntersect,ModuleOptions);observer.handler=handler;observer.ObserverTargets={};observer.observeElement=observeElement;observer.observeElement(targets);globalObj.Observers[name]=observer;};export{createObserver};/**\n * NOTES **\n *\n * target.classList.add('stuck');\n * isInViewCol[zKey].set(true);\t// hooks were less performant by almost half( 653ms in just scripting )\n * of course refs should be used sparingly. But mixing css & js animation seems to work great!\n * plus, intersectionObserver completely eliminates the need to handle event listeners..\n * Not that event listeners don't have their use anymore.\n */ /**\n  * queueFrame() executes passed function or sets value asynchronously through a raf.\n  * Queueing actions in array until they are run or applied. Though I need to find a different\n  * way of triggering css as using custom hooks doesn't yield a lot because hooks are in\n  * themselves asynchronous.\n  * Recorded a 55% performance boost when triggering through 'ref.classList'.\n  * ( 1057ms in only scripting, hard to compare to previous benchmarks though as the\n  * workload was significantly different )\n  * While refs are imperative, most React animation libraries use them and as previously stated\n  * references are required for the use of 'intersectionObserver'.\n  * The important thing to keep in mind is, when using classes, that changes are reset\n  * when components rerender.\n  * Which has many workarounds.\n  */","map":{"version":3,"sources":["C:/webWork/olivertwist/src/logic/zergski-intersection-observer.js"],"names":["globalObj","rafTick","rafQueue","queueFrame","action","push","nextRequest","count","length","Promise","res","rej","window","requestAnimationFrame","i","splice","raf","then","v","Observers","TargetClass","target","handler","prevRatio","elRef","buildThresholdList","steps","thresholds","numSteps","ratio","observeElement","targets","targetsArray","Array","isArray","forEach","tgt","observe","ObserverTargets","zKey","createObserver","name","root","rootMargin","thresholdSteps","delay","originalHandler","observer","ModuleOptions","threshold","ModuleHandleIntersect","entries","entry","intersectionRatio","IntersectionObserver"],"mappings":"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","sourcesContent":["/**\n * Intersection Observer and async raf. Needs cleanup and documentation.\n */\nimport { globalObj } from 'logic/zergski-global-object';\n\n\nlet rafTick = false;\nconst rafQueue = [];\n/**\n * Execute a function or method (or set a state)\n * TODO!: Creating a queue array that removes duplicate or unneeded action and executes\n * the rest in order\n * @param {Function} action\n */\nexport const queueFrame = action => {\n\taction = typeof action !== 'function' ? (() => action) : action;\t// we need a function\n\trafQueue.push(action);\t// add to queue\n\n\tconst nextRequest = () => {\n\t\tlet count = rafQueue.length;\n\t\treturn new Promise(( res, rej ) => {\n\t\t\twindow.requestAnimationFrame(() => {\n\t\t\t\tfor ( let i=0; i<count; i++ ) {\n\t\t\t\t\trafQueue[i]();\n\t\t\t\t}\n\t\t\t\trafQueue.splice(0, count);\n\t\t\t\tres('done');\n\t\t\t});\n\t\t});\n\t}\n\tconst raf = async () => {\n\t\tawait nextRequest().then(v => {\n\t\t\trafQueue.length > 0 ? raf() : rafTick = false;;\n\t\t});\n\t};\n\n\tif (!rafTick) {\n\t\traf();\n\t\trafTick = true;\n\t}\n}\n\n// Object for separation of target values\nglobalObj.Observers = {};\nclass TargetClass {\n\tconstructor( target, handler ) {\n\t\tthis.prevRatio = 1.0;\n\t\tthis.elRef = target;\n\t\tthis.handler = handler;\n\t}\n}\n\n/**\n * handy little function for defining different levels of thresholds\n * returns an int array\n * @param {BigInt} steps\n */\nconst buildThresholdList = ( steps ) => {\n\tlet thresholds = [];\n\tlet numSteps = steps;\n\n\tfor (let i=1.0; i<=numSteps; i++) {\n\t\tlet ratio = i/numSteps;\n\t\tthresholds.push(ratio);\n\t}\n\n\tthresholds.push(0);\n\treturn thresholds;\n}\n\nfunction observeElement( targets ) {\n\t// creating separate object for each target\n\tlet targetsArray = Array.isArray( targets ) ? targets : [ targets ];\n\ttargetsArray.forEach( tgt => {\n\t\tthis.observe( tgt );\n\t\tthis.ObserverTargets[tgt.zKey] = new TargetClass( tgt, this.handler );\n\t});\n}\n\n// intersection observer\nconst createObserver = ( name, root, targets, handler, rootMargin=['0px 0px 0px 0px'], thresholdSteps=20, delay=0, originalHandler=false ) => {\n\tlet observer;\n\n\tlet ModuleOptions = {\n\t\tdelay: delay,\n\t\troot: root,\n\t\trootMargin: rootMargin,\n\t\tthreshold: buildThresholdList(thresholdSteps),\n\t};\n\n\t/**\n\t * Shortening syntax and adding values\n\t * has a callback pointing toward the assigned handler\n\t * @param {*} entries\n\t * @param {*} observer\n\t */\n\tconst ModuleHandleIntersect = ( entries, observer ) => {\n\t\tentries.forEach( entry => {\n\t\t\tlet { zKey } = entry.target;\n\t\t\tlet prevRatio = observer.ObserverTargets[zKey].prevRatio;\n\n\t\t\tobserver.ObserverTargets[zKey].prevRatio = entry.intersectionRatio;\n\t\t\treturn observer.ObserverTargets[zKey].handler({ entry, observer, zKey, prevRatio, entries });\n\t\t});\n\t}\n\n\tobserver = new IntersectionObserver( originalHandler ? handler : ModuleHandleIntersect , ModuleOptions );\n\n\tobserver.handler = handler;\n\tobserver.ObserverTargets = {};\n\tobserver.observeElement = observeElement;\n\tobserver.observeElement( targets );\n\n\tglobalObj.Observers[name] = observer;\n}\n\nexport { createObserver };\n\n\n/**\n * NOTES **\n *\n * target.classList.add('stuck');\n * isInViewCol[zKey].set(true);\t// hooks were less performant by almost half( 653ms in just scripting )\n * of course refs should be used sparingly. But mixing css & js animation seems to work great!\n * plus, intersectionObserver completely eliminates the need to handle event listeners..\n * Not that event listeners don't have their use anymore.\n */\n\n\n\n /**\n  * queueFrame() executes passed function or sets value asynchronously through a raf.\n  * Queueing actions in array until they are run or applied. Though I need to find a different\n  * way of triggering css as using custom hooks doesn't yield a lot because hooks are in\n  * themselves asynchronous.\n  * Recorded a 55% performance boost when triggering through 'ref.classList'.\n  * ( 1057ms in only scripting, hard to compare to previous benchmarks though as the\n  * workload was significantly different )\n  * While refs are imperative, most React animation libraries use them and as previously stated\n  * references are required for the use of 'intersectionObserver'.\n  * The important thing to keep in mind is, when using classes, that changes are reset\n  * when components rerender.\n  * Which has many workarounds.\n  */"]},"metadata":{},"sourceType":"module"}