{"ast":null,"code":"import _slicedToArray from\"C:/webWork/olivertwist/node_modules/@babel/runtime/helpers/esm/slicedToArray\";/**\n * recursive function loop.\n * One for arrays and one for Objects.\n * Same name for both types allows for automatic type detection and conversion.\n */ // name our method\nvar methodName='recLoop';// Check if prototype names are taken\nObject.prototype.hasOwnProperty(methodName)&&THROW_ERROR('Object');Array.prototype.hasOwnProperty(methodName)&&THROW_ERROR('Array');function THROW_ERROR(info){throw new Error(\"Property name '\".concat(methodName,\"' clashes with an existing method in \").concat(info,\" prototypes\"));}// referencing objects\nvar TargetObject=Object;var TargetArray=Array;/**\n * We define our properties and handle data types\n * Our functions receive callbacks and if set\n * an int with a loop limit.\n */Object.defineProperty(TargetObject.prototype,methodName,{value:function value(callback,limit){var array=Object.entries(this);// Object entries are made into arrays\nreturn iterate(callback,array,limit);// and we call our recursive function\n},enumerable:false,writable:true});Object.defineProperty(TargetArray.prototype,methodName,{value:function value(callback,limit){var array=this;// arrays are kept as is\nreturn iterate(callback,array,limit);},enumerable:true,writable:true});/**\n * Recursive function that iterates through\n * an array either in full or up to the set\n * limit of iterations\n * @param {function} callback\n * @param {array} array\n * @param {number} limit\n */function iterate(callback,array){var limit=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;var length=array.length;var count=length<limit?length:limit||length;// iteration count\nvar i=0;function next(){var _ref=Array.isArray(array[i])?array[i]:[array[i]],_ref2=_slicedToArray(_ref,2),entry=_ref2[0],_ref2$=_ref2[1],entry2=_ref2$===void 0?undefined:_ref2$;if(i++>=count){return;}// value, index, key because it's seems easier to handle atm\nreturn callback(entry2||entry,i,entry2&&entry),next();}// Give it a push\nnext();}","map":{"version":3,"sources":["C:/webWork/olivertwist/src/logic/methods.js"],"names":["methodName","Object","prototype","hasOwnProperty","THROW_ERROR","Array","info","Error","TargetObject","TargetArray","defineProperty","value","callback","limit","array","entries","iterate","enumerable","writable","length","count","i","next","isArray","entry","entry2","undefined"],"mappings":"yGAAA;AACA;AACA;AACA;AACA,G,CAEA;AACA,GAAMA,CAAAA,UAAU,CAAG,SAAnB,CAEA;AACAC,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCH,UAAhC,GAA+CI,WAAW,CAAC,QAAD,CAA1D,CACAC,KAAK,CAACH,SAAN,CAAgBC,cAAhB,CAA+BH,UAA/B,GAA8CI,WAAW,CAAC,OAAD,CAAzD,CACA,QAASA,CAAAA,WAAT,CAAuBE,IAAvB,CAA8B,CAAE,KAAM,IAAIC,CAAAA,KAAJ,0BAA8BP,UAA9B,iDAAkFM,IAAlF,gBAAN,CAA8G,CAE9I;AACA,GAAME,CAAAA,YAAY,CAAGP,MAArB,CACA,GAAMQ,CAAAA,WAAW,CAAGJ,KAApB,CAEA;AACA;AACA;AACA;AACA,GACAJ,MAAM,CAACS,cAAP,CAAuBF,YAAY,CAACN,SAApC,CAA+CF,UAA/C,CAA2D,CAC1DW,KAAK,CAAE,eAAUC,QAAV,CAAoBC,KAApB,CAA4B,CAClC,GAAIC,CAAAA,KAAK,CAAGb,MAAM,CAACc,OAAP,CAAe,IAAf,CAAZ,CAAkC;AAElC,MAAOC,CAAAA,OAAO,CAAEJ,QAAF,CAAYE,KAAZ,CAAmBD,KAAnB,CAAd,CAAyC;AAEzC,CANyD,CAMvDI,UAAU,CAAE,KAN2C,CAMpCC,QAAQ,CAAE,IAN0B,CAA3D,EAQAjB,MAAM,CAACS,cAAP,CAAsBD,WAAW,CAACP,SAAlC,CAA6CF,UAA7C,CAAyD,CACxDW,KAAK,CAAE,eAAUC,QAAV,CAAoBC,KAApB,CAA4B,CAClC,GAAIC,CAAAA,KAAK,CAAG,IAAZ,CAAmB;AAEnB,MAAOE,CAAAA,OAAO,CAAEJ,QAAF,CAAYE,KAAZ,CAAmBD,KAAnB,CAAd,CAEA,CANuD,CAMrDI,UAAU,CAAE,IANyC,CAMnCC,QAAQ,CAAE,IANyB,CAAzD,EASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAASF,CAAAA,OAAT,CAAkBJ,QAAlB,CAA4BE,KAA5B,CAAgD,IAAbD,CAAAA,KAAa,2DAAP,IAAO,CAC/C,GAAIM,CAAAA,MAAM,CAAGL,KAAK,CAACK,MAAnB,CACA,GAAMC,CAAAA,KAAK,CAAGD,MAAM,CAAGN,KAAT,CAAiBM,MAAjB,CAA0BN,KAAK,EAAIM,MAAjD,CAA0D;AAC1D,GAAIE,CAAAA,CAAC,CAAG,CAAR,CAEA,QAASC,CAAAA,IAAT,EAAgB,UACmBjB,KAAK,CAACkB,OAAN,CAAcT,KAAK,CAACO,CAAD,CAAnB,EAA0BP,KAAK,CAACO,CAAD,CAA/B,CAAqC,CAACP,KAAK,CAACO,CAAD,CAAN,CADxD,8BACTG,KADS,0BACFC,MADE,iBACKC,SADL,QAEf,GAAKL,CAAC,IAAMD,KAAZ,CAAoB,CAAE,OAAQ,CAE9B;AACA,MAASR,CAAAA,QAAQ,CAAEa,MAAM,EAAID,KAAZ,CAAmBH,CAAnB,CAAsBI,MAAM,EAAID,KAAhC,CAAR,CAAiDF,IAAI,EAA9D,CACA,CAAC;AACFA,IAAI,GACJ","sourcesContent":["/**\n * recursive function loop.\n * One for arrays and one for Objects.\n * Same name for both types allows for automatic type detection and conversion.\n */\n\n// name our method\nconst methodName = 'recLoop';\n\n// Check if prototype names are taken\nObject.prototype.hasOwnProperty(methodName) && THROW_ERROR('Object');\nArray.prototype.hasOwnProperty(methodName) && THROW_ERROR('Array');\nfunction THROW_ERROR ( info ) { throw new Error( `Property name '${ methodName }' clashes with an existing method in ${ info } prototypes` ) }\n\n// referencing objects\nconst TargetObject = Object;\nconst TargetArray = Array;\n\n/**\n * We define our properties and handle data types\n * Our functions receive callbacks and if set\n * an int with a loop limit.\n */\nObject.defineProperty( TargetObject.prototype, methodName, {\n\tvalue: function( callback, limit ) {\n\t\tlet array = Object.entries(this);\t// Object entries are made into arrays\n\n\t\treturn iterate( callback, array, limit )\t// and we call our recursive function\n\n\t}, enumerable: false, writable: true\n});\nObject.defineProperty(TargetArray.prototype, methodName, {\n\tvalue: function( callback, limit ) {\n\t\tlet array = this;\t\t// arrays are kept as is\n\n\t\treturn iterate( callback, array, limit );\n\n\t}, enumerable: true, writable: true\n});\n\n/**\n * Recursive function that iterates through\n * an array either in full or up to the set\n * limit of iterations\n * @param {function} callback\n * @param {array} array\n * @param {number} limit\n */\nfunction iterate( callback, array, limit=null ) {\n\tlet length = array.length;\n\tconst count = length < limit ? length : limit || length ;\t// iteration count\n\tlet i = 0;\n\n\tfunction next() {\n\t\tlet [ entry, entry2=undefined ] = Array.isArray(array[i]) ? array[i] : [array[i]];\n\t\tif ( i++ >= count ) { return }\n\n\t\t// value, index, key because it's seems easier to handle atm\n\t\treturn ( callback( entry2 || entry, i, entry2 && entry ), next() );\n\t}\t// Give it a push\n\tnext();\n}"]},"metadata":{},"sourceType":"module"}